<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#">
<head>
  <meta charset="UTF-8" />
  <title>Day8 调试 | The_toast Blog</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="/static/m-dark.css" />
  <link rel="icon" href="/m" type="." />
  <link rel="canonical" href="/软件测试/Day8 调试.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
  <meta name="twitter:site" content="@your.brand" />
  <meta name="twitter:site:id" content="1234567890" />
  <meta property="og:site_name" content="The_toast Blog" />
  <meta property="og:title" content="Day8 调试" />
  <meta name="twitter:title" content="Day8 调试" />
  <meta property="og:url" content="/软件测试/Day8 调试.html" />
  <meta property="og:description" content="Day8 调试 第 7 章 调试(DEBUGGING) 7 章 调试(DEBUGGING) 简单地讲，调试是执行一次成功的测试之后所要进行的工作。记住，所谓成功 的测试，是指 …" />
  <meta name="twitter:description" content="Day8 调试 第 7 章 调试(DEBUGGING) 7 章 调试(DEBUGGING) 简单地讲，调试是执行一次成功的测试之后所要进行的工作。记住，所谓成功 的测试，是指 …" />
  <meta property="og:image" content="https://your.brand/static/site.png" />
  <meta name="twitter:image" content="https://your.brand/static/site.png" />
  <meta name="twitter:card" content="summary" />
  <meta property="og:type" content="article" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="/" id="m-navbar-brand" class="m-col-t-9 m-col-m-none m-left-m">The_toast Blog</a>
      <a id="m-navbar-show" href="#navigation" title="Show navigation" class="m-col-t-3 m-hide-m m-text-right"></a>
      <a id="m-navbar-hide" href="#" title="Hide navigation" class="m-col-t-3 m-hide-m m-text-right"></a>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="/category/shou-ye.html">博客首页</a></li>
            <li><a href="/category/ruan-jian-ce-shi.html">软件测试</a></li>
            <li><a href="/category/jing-yan-lei-ji.html">经验积累</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="4">
            <li><a href="/category/blog.html" id="m-navbar-current">BLog</a></li>
            <li><a href="/hgxtester.html">个人介绍</a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main>
<div class="m-container">
  <div class="m-row">
    <article class="m-col-m-10 m-nopadb">
      <header>
        <h1 style="font-size: 2.2rem;margin-top: 30px;"><a href="/软件测试/Day8 调试.html" rel="bookmark" title="Permalink to Day8 调试">
          <time class="m-date" datetime="2023-05-25T20:38:43.258681+02:00">
            5月 <span class="m-date-day">25</span> 2023
          </time>
          Day8 调试
        </a></h1>
        <p>Day8 调试</p>
        <p><strong>第</strong> <strong>7</strong> <strong>章 调试</strong><strong>(DEBUGGING)</strong></p>
        <p><strong>7</strong> <strong>章 调试</strong><strong>(DEBUGGING)</strong> </p>
        <p>简单地讲，调试是执行一次成功的测试之后所要进行的工作。记住，所谓成功</p>
        <p>的测试，是指 …</p>
      </header>
      <div class="m-clearfix-l"></div>
<!-- content -->
<p>Day8 调试</p>
<p><strong>第</strong> <strong>7</strong> <strong>章 调试</strong><strong>(DEBUGGING)</strong></p>
<p><strong>7</strong> <strong>章 调试</strong><strong>(DEBUGGING)</strong> </p>
<p>简单地讲，调试是执行一次成功的测试之后所要进行的工作。记住，所谓成功</p>
<p>的测试，是指它可以证明程序没有实现预期的功能。调试是一个包含两个步骤的过</p>
<p>程，从执行了一个成功的测试用例、发现了一个问题之后开始。第一步，确定程序</p>
<p>中可疑错误的准确性质和位置；第二步，修改错误。</p>
<p>虽然调试对于程序测试来说非常必要、不可或缺，但它似乎是软件开发过程中</p>
<p>最不受程序员欢迎的部分之一。其主要原因可能包括以下几点：</p>
<p>• <strong>个人自尊会从中阻挠</strong>。不管我们是否喜欢，调试都说明了程序员并不完美，</p>
<p>要么在软件的设计，要么在程序编码时会犯错。</p>
<p>• <strong>热情耗尽</strong>。在所有的软件开发活动中，调试是最耗费脑力的苦差事，况且，</p>
<p>进行调试往往经受着来自机构或自身的巨大压力，必须尽可能快地改正问</p>
<p>题。</p>
<p>• <strong>可能会迷失方向</strong>。调试是艰苦的脑力工作，因为发现的错误实际上可能会</p>
<p>出现在程序的任何语句中。也就是说，如果不首先检查程序，我们就不能</p>
<p>绝对地肯定在一个薪金管理程序出具的支票中出现的数字错误不是由某个</p>
<p>子程序引起的，该子程序要求操作员将一个特定的表格传输给打印机。让</p>
<p>我们以诊断一个物理系统为例子作对比，如汽车。假如汽车在爬坡时熄火</p>
<p>了（症状），那么我们可能会迅速而有效地排除掉某些部件——调频/调幅</p>
<p>收音机、速度表或汽车门锁——引起该故障的可能。根据我们对汽车引擎</p>
<p>的整体了解，该故障一定是发生在引擎上，我们甚至可以排除掉某些引擎</p>
<p>部件，如水箱和滤油器。</p>
<p>• <strong>必须自力更生</strong>。与其他软件开发活动相比，关于调试过程的研究、资料和</p>
<p>正式的指南都比较少。</p>
<p>尽管本书是关于软件测试的，并不讨论调试，但这两个过程显然是相互联系的。</p>
<p>针对调试的两个步骤，即错误定位和错误修改，对错误进行定位可能解决了 95％的</p>
<p>问题。因此，本章集中讨论错误的定位过程，当然是假定某个成功的测试用例已经</p>
<p>发现了一个错误。</p>
<p><strong>7.1</strong> <strong>暴力法调试</strong><strong>(Debugging by Brute Force)</strong> </p>
<p>调试程序的最为普遍的模式是所谓的“暴力”方法。这种方法之所以流行，是</p>
<p>因为它不需要过多思考，是耗费脑力最少的方法，但同时也效率低下，通常来讲不</p>
<p>是很成功。</p>
<p>暴力调试方法可至少被划分为三种类型：</p>
<p>\1. 利用内存信息输出来调试。</p>
<p>\2. 根据一般的“在程序中插入打印语句”建议来调试。</p>
<p>\3. 使用自动化的调试工具进行调试。</p>
<p>第一种类型，使用内存信息输出（通常使用十六进制或八进制格式粗略地显示</p>
<p>所有的存储区域）是最缺乏效率的暴力调试方法，原因如下：</p>
<p>• 难以在内存区域写源程序中的变量之间建立对应关系。</p>
<p>• 即使对下复杂程度较低的程序，内存信息输出也会产生数最非常庞大的数</p>
<p>据，其中的大多数都是与调试无关的。</p>
<p>• 内存信息输出显示的是程序的静态快照，仅能显示出在某一个时刻程序的</p>
<p>状态；为了发现错误，还需要研究程序的动态状态（随时间的状态变化）。 </p>
<p>• 内存信息输出很少可以精确地在错误发生的地方产生，因此无法显示在错</p>
<p>误发生时程序的状态。错误发生到输出内存信息这段时间之内程序执行的</p>
<p>活动，可能会掩盖掉发现错误所需的线素。</p>
<p>• 通过分析输出的内存信息来发现问题的方法并不大多（因此很名程序员都</p>
<p>是密切注视，急切地渴望着错误能神奇地从内存信息输出中自行暴露出</p>
<p>来）。</p>
<p>第二种类型，在失效的程序中插入输出变量值的语句，这种做法也不具有很强</p>
<p>的优势。它可能比内存信息输出要好一些，因为可以显示程序的动态状态，让我们</p>
<p>检查的信息可以相对容易地与源程序联系起来。但是这种方法同样也有很多缺点：</p>
<p>• 它不是鼓励我们去思考程序中的问题，而主要是一种碰运气的方法。</p>
<p>• 它所产生的需要分析的数据量非常庞大。</p>
<p>• 它要求我们修改程序，这些修改可能会掩盖掉错误、改变关键的时序关系，</p>
<p>或者会引入新的错误。</p>
<p>• 它可能对小型程序有效，但如果应用到大型程序，成本就相当高。况且对</p>
<p>于某些类型的程序，如操作系统或过程控制软件，这种办法甚至无法使用。</p>
<p>第三种类型，自动化调试工具的工作机制类似于在程序中插入打印语句，</p>
<p>但是并不修改程序本身。可以使用编程语言的调试功能，或使用特殊的交互式</p>
<p>调试工具来分析程序的动态状态。可能会用到的典型的语言功能有：产生可打</p>
<p>印的语句执行轨迹的机制、子程序调用以及/或者对特定变量的修改等。调试工</p>
<p>具的一个共同的功能是可以设置断点，使程序在执行到某条特定语句或改动了</p>
<p>某个特定变量的值时暂停执行，然后程序员就可以检查程序的当前状态。同样，</p>
<p>这种方法也主要是在碰运气，常常会生成数量过于庞大的无关数据。</p>
<p>这些暴力调试方法的主要问题在于：它们都忽略了思考的过程。我们可以</p>
<p>在调试程序和侦破谋杀案之间找出相似点来。实际上，在几平所有的谋杀悬念</p>
<p>小说中，谜案都是通过仔细分析线索，将表面上不重要的细节全联结起来而最</p>
<p>终侦破的。这不是一个使用蛮力的方法，要使用蛮力的是寻觅障碍物或搜寻财</p>
<p>宝。</p>
<p>还有些证据表明，无论调试小组成员是富有经验的程序员还是学生，肯动</p>
<p>脑筋而不是依赖别人帮助的人能够更快、更准确地发现程序错误。因此，我们</p>
<p>建议仅在下列情况下使用暴力调试方法：（</p>
<p>l）其他的方法都失败了：（</p>
<p>2）作为</p>
<p>我们下面将会讨论的思考过程的补充，而不是替代方法。</p>
<p><strong>7.2</strong> <strong>归纳法调试</strong><strong>(Debugging by Induction)</strong> </p>
<p>很显然，认真的思考能够发现大部分错误，甚至不需要调试人员使用调试</p>
<p>工具．归纳是一种特殊的思考过程，可以从细节转到全局，也就是从线索（即</p>
<p>错误的症状，可能是一个或多个测试用例的结果）出发，寻找线索之间的联系。</p>
<p>归纳的过程如图 7-1 所示。</p>
<p>归纳调试的步骤如下：</p>
<p>\1. 确定相关数据。调试人员犯的一个主要错误是未能将所有可用的数据或症</p>
<p>状都考虑进去。第一步是列举出所有知道的程序执行的正确和不正确之处，</p>
<p>这些不正确之处即是症状，让我们相信确实存在错误。那些相似却不相同、</p>
<p>且未引起症状出现的测试用例提供了额外的有价值的线索。</p>
<p>\2. 组织数据。记住，归纳意味着从特殊到一般，因此第二步是组织这些相关</p>
<p>数据，以便观察线索间的模式，尤其重要的是要找到矛盾、事件，比如仅</p>
<p>当客户的保险金账户收支不太平衡时出现的错误。我们可以采用图 7-2 所</p>
<p>示的表格来组织现有的数据。“是什么”框列举的是总体的症状，“在何处”</p>
<p>框描述了这些症状出现的地方，“多大程度”框描述了这些症状的范围和重</p>
<p>要性。注意“是”和“否’列，它们所描述的矛盾之处最终可能会导致对</p>
<p>错误的假设。</p>
<p><strong>? Is Is not</strong> </p>
<p>What </p>
<p>Where </p>
<p>When </p>
<p>To what next </p>
<p>图 7-2 组织线索的一种方法</p>
<p>\3. 做出假设。下一步是研究线索之间的联系，利用线索结构里可能的模式做</p>
<p>出一个或多个关于错误原因的假设。如果还无法做出推测，就需要更多的</p>
<p>数据。如果可能有多个假设存在，首先选择最有能的一个。</p>
<p>\4. 证明假设。考虑到调试在进行时所承受的压力，这个时期最主要的错误是</p>
<p>忽略了这个阶段，直接跳到结论去改正问题。但是在继续下一步之前，证</p>
<p>明这些假设的合理性是非常重要的。如果忽略了这一步，可能接下去只修</p>
<p>改了问题症状，而没解决问题本身。应将假设与其最初的线索或数据相比</p>
<p>较，以此来证明假设的合理性，确定这些假设可以完全解释这些线索的存</p>
<p>在。如果无法解释，要么这些假设是无效的或不完整的，要么还有更多的</p>
<p>错误存在。</p>
<p>举一个简单的例子、假设在第 4 章描述的考试评分软件报告了一个明显的错</p>
<p>误。错误是在某些但不是所有情况下，中间值似乎不正确。在某个特殊的测试用例</p>
<p>中，有 51 名学生被评分。正确打印出宋的平均分数为 73.2，但打印出的中间值是</p>
<p>26 分，而不是预期的 82 分。经过对该测试用例及其他一些测试用例结果的检查，</p>
<p>线索按图 7-3 所示的形式进行组织。</p>
<p><strong>? Is Is not</strong> </p>
<p>What </p>
<p>报告 3 中显示的中间值不正</p>
<p>确</p>
<p>计算平均值或标准偏差时出</p>
<p>现</p>
<p>Where </p>
<p>仅在报告 3 中出现 </p>
<p>在其它报告中出现。学生成绩</p>
<p>的计算似乎正确</p>
<p>When </p>
<p>当测试学生为 51 时发生 </p>
<p>在测试学生数量为 2 和 200</p>
<p>时未发生</p>
<p>To what next </p>
<p>显示的中间值为 26。当学生</p>
<p>数量为 1 时也同样发生，显示</p>
<p>的中间值。</p>
<p>图 7-3 组织线索的例子</p>
<p>下一步是通过寻找模式和矛盾之处，做出关于该错误的假设。我们看到的一个</p>
<p>矛盾是这个错误似乎出现在学生人数为奇数的测试用例中，这也许是个巧合，但看</p>
<p>来很重要，因为我们要根据学生人数为奇数或偶数而不同地计算中间值。还有一个</p>
<p>奇怪的模式：在些测试用例中，计算出来的中间值总是小于或等于学生的人数（26</p>
<p>小等于 51，l 小等于 1）。这时，一个可能的方法是再重新运行一次学生人数为 51</p>
<p>名的测试用例，给学生打与以前不同的分数，看一下是如何影响中间依的计算的。</p>
<p>如果中间值仍然是 26，那么“否——多大程度”框可以填上“中间值似乎与实际分</p>
<p>数无关”。尽管这个结果提供了一条有价值的线索，但即使没有它，我们可能已经软件测试的艺术</p>
<p>未经同意，严禁以任何形式拷贝 </p>
<p>123</p>
<p>能够猜出这个错误来。从现有数据计算出的中间值似乎等于学生人数的一半，经过</p>
<p>四舍五入后得到最接近的一个整数。换句话说，如果将分数设想为存储在一个分类</p>
<p>表里，该程序打印的是中间学生的人数而不是其成绩。因此，我们有了一个关于该</p>
<p>错误准确性质的坚定的假设。下一步就是通过检查代码或执行一些附加的测试用例</p>
<p>来证明这个假设。</p>
<p><strong>7.3</strong> <strong>演绎法调试</strong><strong>(Debugging by Deduction)</strong> </p>
<p>演绎的过程是从一些普遍的理论或前提出发，使用排除和精炼的过程，达到一</p>
<p>个结论（错误的位置），参见图 7- 4 。</p>
<p>列出可能</p>
<p>的原因</p>
<p>使用排除</p>
<p>法</p>
<p>提炼剩下</p>
<p>的假设</p>
<p>证明剩下</p>
<p>的假设</p>
<p>收集更多</p>
<p>数据</p>
<p>都被排除 不能</p>
<p>能 </p>
<p>修改错误</p>
<p>图 7-4 使用演绎法的调试过程</p>
<p>举个谋杀犯的例子，与归纳过程相反，首先从一系列嫌疑人入手，通过排除（花</p>
<p>匠有当时不在现场的合理证词）和提炼（罪犯可能是红色头发）的过程，判断出管</p>
<p>家可能犯了罪。演绎的步骤如下：</p>
<p>\1. 列举出所有可能的原因或假设．第一步是建立一份所有想象得到的错误线</p>
<p>索的清单，线索不需要有完整的解释，它们纯粹是一些推测，帮助我们组</p>
<p>织和分析现有的数据。</p>
<p>\2. 利用数据排除可能的原因。详细检查所有的数据，尤其寻找存在矛盾的地</p>
<p>方（图 7-2 可以用在此处），然后尽量排除所有可能的原因，仅留下一条，</p>
<p>如果所有的原因都排除掉了，需要增加额外的测试用例，得到更多的数据</p>
<p>来设计新的推测。如果剩下的原因多于一个，那么首先选择最有可能的原</p>
<p>因，即主要假设。</p>
<p>\3. 提炼剩下的假设。此时的可能原因也许是正确的,但可能不够具体，不能指第 7 章 调试(DEBUGGING) </p>
<p>未经同意，严禁以任何形式拷贝 </p>
<p>124</p>
<p>出错误来。因此，下一步是使用现有的线索来提炼这个推侧．举例来说，</p>
<p>我们可能会首先想到“对文件中最后事务的处理可能存在错误”，并将其提</p>
<p>炼为“缓冲区中的最后事务被文件结束指示器覆盖” 。</p>
<p>\4. 证明剩下的假设。这个重要步骤与归纳法中的第 4 步骤相同。</p>
<p>举个例子，假设我们着手对第 4 章讨论的 DISPLAY 命令进行功能测试。在由</p>
<p>因果图分析方法确定的 38 个测试用例中，我们首先使用 4 个测试用例。作为建立</p>
<p>输入条件过程的一部分，我们对内存进行初始化，将第一个、第五个、第九个、…</p>
<p>字的值设置为 0000，将第二个、第六个、… 字的值设置为 4444 ，将第三个、第</p>
<p>七个、…字的值设置为 8888，将第四个、第八个、… 字的值设置为 CCCC。也就</p>
<p>是说，每个内存字单元都初始化为每个字的首字节地址中的低位十六进制数字</p>
<p>（23FC、23FD、23FE 和 23FF 地址的值为 C）。 </p>
<p>图 7-5 显示了这些测试用例、预期的输出及测试用例的实际输出。</p>
<p>显然，我们遇到了一些问题，所有的测试用例都没有产生预期的结果（全部都</p>
<p>成功了）。让我们从调试与第一个测试用例相关的错误开始。该命令表明，从 0 地</p>
<p>址开始（默认情况），要显示 E（十进制中的 14）个地址（回忆一下，规格说明定</p>
<p>义所有的输出应每行包括 4 个字或 16 个字节）。</p>
<p><strong>测试用例的输入</strong> </p>
<p><strong>预期的输出</strong> </p>
<p><strong>实际的输出</strong></p>
<p>DISPLAY </p>
<p>0000 = 0000 4444 8888 CCCC M1 INVALID COMMAND </p>
<p>SYNTAX </p>
<p>DISPLAY 21v-29 0000020 ＝ 0000 4444 8888 CCCC 000020 = 4444 8888 CCCC 0000 </p>
<p>DISPLAY.11 000010 = 0000 4444 8888 CCCC </p>
<p>000010 = 0000 4444 8888 CCCC </p>
<p>000000 = 0000 4444 8888 CCCC </p>
<p>DISPLAY 8000-END M2 STORAGE REOUESTED IS </p>
<p>BEYOND ACTUAL MEMORY </p>
<p>LIMITS </p>
<p>008000 = 0000 4444 8888 CCCC </p>
<p>图 7-5 DISPLAY 命令的测试用例输出结果</p>
<p>为出现的不期望的错误信息列举可能的原因：</p>
<p>\1. 程序不能接受单词 DISPLAY。</p>
<p>\2. 程序不能接受句号。</p>
<p>\3. 程序不允许第一个操作数为默认情况。程序要求在句号之前声明一个存储</p>
<p>地址。软件测试的艺术</p>
<p>未经同意，严禁以任何形式拷贝 </p>
<p>125</p>
<p>\4. 程序不允许 E 作为有效的字节数量。</p>
<p>下一步是尽力排除这些原因。如果所有原因都排除掉了，那么需要退回去并扩</p>
<p>充一下原因的清单。如果剩下来的原因超过了一个，那么就需要检验额外的测试用</p>
<p>例以确定惟一的错误假设，或继续使用可能性最大的原因。由于我们手上还有其他</p>
<p>测试用例，可以看到图 7-5 中的第二个测试用例似乎可以排除掉第 1 条假设，而第</p>
<p>三个测试用例尽管产生了错误的结果，也似乎可以排除掉第 2 和第 3 条假设。</p>
<p>下一步是提炼第 4 条假设。它看上去足够具体，但直觉告诉我们实质的内容要</p>
<p>比表面上看到的多。它看上去似乎是一个更为一般的错误实例。那么我们可以认为</p>
<p>程序不能正确识别特殊的十六进制字符 A～F 。在其他测试用例中缺少这些字符，</p>
<p>使得这听起来是一个行得通的解释。然而我们不能马上得出结论，而应该首先考虑</p>
<p>所有的已知信息。第四个测试用例可能代表一个完全不同的错误，也可能提供了一</p>
<p>条关于当前错误的线索。假设系统的最高有效地址是 7FFF，那么第四个测试用例</p>
<p>将如何显示一个明显不存在的区域呢？显示的值是我们初始化后的值而不是无用</p>
<p>的信息，这个事实让我们推测该命令不知何故显示了 0～7FFF 之间的某些内容。</p>
<p>我们可能会想到，这种错误也许会发生在程序将命令的操作数当成十进制数（而不</p>
<p>是规格说明中要求的十六进制数）的情况，第三个测试用例证实了这种假设，程序</p>
<p>并未显示 32 个字节的内存单元的内容，而仅显示了 16 个字节，这与我们的假设是</p>
<p>一致的，即“11”被当作了十进制数。因此，提炼后的假设是，程序将字节数当作</p>
<p>内存地址处理，并将输出列表中的内存地址当作十进制数。最后的步骤是证明该假</p>
<p>设。看一看第四个测试用例，如果 8000 被解读为十进制数，则对应的十六进制数</p>
<p>是 1F40 ，这样就会产生我们所看到的输出。作为进一步的证据，检查第二个测试</p>
<p>测试用例。输出是不正确的，但如果 21 和 29 被当作十进制数，那么内存地址 15～</p>
<p>ID 中的内容将被显示出来，这是与测试用例的错误结果是一致的。因此，我们几</p>
<p>乎可以确切地定位错误了：程序认为操作数是十进制数，并将内存地址按十进制的</p>
<p>值打印出来，这与规格说明是不符的。而且，这个错误似乎是造成所有四个测试用</p>
<p>例产生错误结果的原因。经过一些思考，我们发现了这个错误，同时也解决了其他</p>
<p>三个乍看起来毫不相关的问题。</p>
<p>注意，该错误可能在程序中的两个地方显现出来：解释输入命令的部分和在输第 7 章 调试(DEBUGGING) </p>
<p>未经同意，严禁以任何形式拷贝 </p>
<p>126</p>
<p>出列表上打印内存地址的部分。</p>
<p>说句离题的话，这个可能由于错误理解规格说明而引起的错误进一步印证了我</p>
<p>们的建议，即程序员不应该测试自己编写的程序。如果程序员在犯了这个错误之后</p>
<p>仍然去设计测试用例，很有可能在编写测试用例时犯同样的错误。换句话说，程序</p>
<p>员预料的输出将不同于图 7-5 所示的；这些输出将是按操作数是十进制数的理解而</p>
<p>被计算出来的，因此这个基本的错误可能不会被察觉到。</p>
<p><strong>7.4</strong> <strong>回溯法调试</strong><strong>(Debugging by Backtracking)</strong> </p>
<p>在小型程序中定位错误的一种有效方法是沿着程序的逻辑结构回溯不正确的</p>
<p>结果，直到找出程序逻辑出错的位置。换句话说，从程序产生不正确结果（如打印</p>
<p>了不正确的数据）的地方开始，从该处观察到的结果推断出程序变量应该是些什么</p>
<p>值。在头脑中，从这个位置开始逆向执行程序，重复使用“如果程序在此处的状态</p>
<p>是这样的，那么程序在上面位置的状态就必然是那样的”过程，就能很快定位出错</p>
<p>误。使用这个过程，可以确定程序中从状态符合预期值的位置点，到第一个状态不</p>
<p>符合预期值的位置点之间的范围。</p>
<p><strong>7.5</strong> <strong>测试法调试</strong><strong>(Debugging by Testing)</strong> </p>
<p>最后一个“思维型”的调试方法是使用测试用例。这可能听起来有些奇怪，因</p>
<p>为从本章一开始就将调试和测试区分了开来。然而，考虑下面两种类型的测试用例。</p>
<p>供测试的测试用例，其目的是暴露出以前尚未发现的错误．供调试的测试用例，其</p>
<p>目的是提供有用的信息，供定位某个被怀疑的错误之用。两者之间的区别是，供测</p>
<p>试的测试用例会“胖”一些，因为我们尽量使用较少数量的测试用例来涵盖较多的</p>
<p>条件，而供调试的测试用例则“瘦”一些，因为每个测试用例仅需要覆盖一个或几</p>
<p>个条件。</p>
<p>换句话说，当发现了某个被怀疑的错误的症状之后，我们需要编写与原先有所</p>
<p>变化的测试用例，尽量确定错误的位置。实际上，这种方法不是一个完全独立的方</p>
<p>法；它常常结合归纳法一起使用，以获得进行假设和/或证明假设所需的信息。它也</p>
<p>可以和演绎法一起使用，以排除有嫌疑的原因，提炼剩下的假设，并/或证明假设。软件测试的艺术</p>
<p>未经同意，严禁以任何形式拷贝 </p>
<p>127</p>
<p><strong>7.6</strong> <strong>调试的原则</strong></p>
<p>在本节中，我们将讨论一系列的调试原则，在实质上也是心理学的原则。与第</p>
<p>2 章的测试原则情况一样，这些调试原则有很多在直观上很明显，但却常常被遗忘</p>
<p>或忽略。由于调试的过程由两部分组成，即定位错误及修改错误，因此我们也将讨</p>
<p>论两类原则，</p>
<p><strong>7.6.1</strong> <strong>定位错误的原则</strong></p>
<p><strong>1.</strong> <strong>动脑筋</strong></p>
<p>前面的章节隐含指出，调试是一个解决问题的过程。最为有效的调试方法</p>
<p>是动脑筋对错误症状的有关信息进行分析。一个高效的程序调试人员应该不使</p>
<p>用计算机就能定位大多数的错误。</p>
<p><strong>2.</strong> <strong>如果遇到了僵局，就留到稍后解决</strong></p>
<p>人类的潜意识是一个潜在的问题求解器。我们经常提到的所谓灵感，其实</p>
<p>就是当人类的意识停留在诸如吃东西、走路或看电影之上时，潜意识却正在思</p>
<p>考另一个向题。如果在合理时间内（也许小型程序为 30 分钟，大一点的程序为</p>
<p>几个小时），我们还不能定位某个间题，就丢开它，做些其他的事情，因为思维</p>
<p>的效率开始明显下降。忘记这个问题一段时间之后，我们的潜意识可能已经解</p>
<p>决了它，或者思维会焕然一新，可以重新检查问题的症状。</p>
<p><strong>3.</strong> <strong>如果遇到了困境，就把问题描述给其他人听</strong></p>
<p>与其他人交谈可能会帮助我们发现一些新的东西。事实上，经常是仅仅将</p>
<p>问题描述给一个好的倾听者时，我们就会突然找到问题的解决之道，而无需倾</p>
<p>听者提供任何帮助。</p>
<p><strong>4.</strong> <strong>仅将测试工具作为第二种手段</strong></p>
<p>在试过了其他的方法之后才使用调试上具，并将其作为头脑思考的辅助手</p>
<p>段，而不是替代手段。正如本章前面所述，调试工具比如输出和跟踪工具，代</p>
<p>表的是一种偶然的调试方法。经验证明，不使用工具的人即使在调试并不熟悉第 7 章 调试(DEBUGGING) </p>
<p>未经同意，严禁以任何形式拷贝 </p>
<p>128</p>
<p>的程序时，也要比使用工具的人更为成功。</p>
<p><strong>5.</strong> <strong>避免使用试验法——仅将其作为最后的手段</strong></p>
<p>调试程序的新手最常犯的错误是为了解决问题而试验性地去修改程序。调</p>
<p>试者可能会说：“我知道什么出错了，所以我要改动一下语句．看一看会发生什</p>
<p>么”。这种纯粹是无计划的方法甚至不属于调试．它表现的是盲目的行动。它获</p>
<p>得成功的机会不仅很小，而且还会将新的错误引入程序，使问题更为复杂。</p>
<p><strong>7.6.2</strong> <strong>修改错误的技术</strong></p>
<p><strong>1.</strong> <strong>存在一个缺陷的地方，很有可能还存在其他缺陷</strong></p>
<p>这是对本书第 2 章原则的重申，即发现程序某个部分存在一个错误时，该</p>
<p>部分存在其他错误的可能性要高于没有发现错误时的可能性。换句话说，错误</p>
<p>有扎堆的倾向。在修改某个问题的同时，应检查下紧临的地方，看看有没有任</p>
<p>何可能是错误之处。</p>
<p><strong>2.</strong> <strong>应纠正错误本身，而不仅是其症状</strong></p>
<p>另一个普遍的错误做法是只修改了错误的症状或仅仅是该错误的一个实</p>
<p>例，而不是错误本身。如果所做的改正不符合错误的所有线索，那么可能只修</p>
<p>改了错误的一部分。</p>
<p><strong>3.</strong> <strong>正确纠正错误的可能性并非</strong> <strong>100%</strong> </p>
<p>如果将这个观点告诉一些人，他们当然会表示赞同，但是如果将它说给正</p>
<p>在修改错误的人听，答案就可能不一样了(“是的，对大多数情况是这样，但这</p>
<p>个修改如此之小，它肯定百分之百地正确”）。我们永远也不要假设为纠正错误</p>
<p>而增加到程序中的代码是正确的。用新的语句替换原来的语句，这种修改要远</p>
<p>比程序中原先的代码更易发生错误。言外之意是应对错误的修改进行测试，也</p>
<p>许比对原先程序的测试还要严格。一个严格的回归测试计划可以确保对某个错</p>
<p>误的修改没有在程序的其他位置引入另外的错误。</p>
<p><strong>4.</strong> <strong>正确修改错误的可能性随着程序规模的增加而降低</strong>软件测试的艺术</p>
<p>未经同意，严禁以任何形式拷贝 </p>
<p>129</p>
<p>换句话说，根据我们的经验，由于修改不正确而引人的错误与原始错误之</p>
<p>比，在规模较大的程序中呈递增趋势。对于一个广泛使用的大型程序，每发现</p>
<p>6 个新错误，其中就有 l 个错误是由干先前对程序的改正而造成的。</p>
<p><strong>5.</strong> <strong>应意识改正错误会引入新错误的可能性</strong></p>
<p>我们不仅需要考虑到不正确的修改，而且还必须考虑到某个看似正确的修</p>
<p>改会产生未料到的副作用，比如引入了一个新错误。不仅存在修改无效的可能，</p>
<p>还存在修改引入了新错误的可能。言外之意是，不仅应在修改之后对错误的情</p>
<p>境进行测试，还应执行回归测试以判断是否引入了新错误。</p>
<p><strong>6.</strong> <strong>修改错误的过程也是临时回到设计阶段的过程</strong></p>
<p>我们应该认识到修改错误也是程序设计的一种形式。在认识到修改易产生</p>
<p>错误的性质之后，常识告诉我们，在设计阶段使用的任何规程、方法和形式都</p>
<p>同样适用于错误修改阶段。举例来说，如果项目证明代码检查很管用，那么在</p>
<p>修改错误之后进行代码检查就显得倍加重要。</p>
<p><strong>7.</strong> <strong>应修改源代码，而不是目标代码</strong></p>
<p>在调试大型系统，尤其是用汇编语言编写的系统时，偶尔会存在这样的修</p>
<p>改错误的倾向，即先立即修改目标代码．稍后再修改源程序．这种方法带来了</p>
<p>两个问题，（1）这通常是“通过试验进行调试”的信号；（</p>
<p>2）目标代码与源程</p>
<p>序不同步，这意味着当程序重新编译或重新汇编之后，同样的错误很容易又浮</p>
<p>现出来，这是一种草率的、不专业的调试方法。</p>
<p><strong>7.7</strong> <strong>错误分析</strong></p>
<p>有关程序调试最后一个应认识之处是，调试除了有消灭程序中错误的价值之</p>
<p>外，还有其他重要作用：它可以告诉我们软件错误的一些本质．我们对此了解得非</p>
<p>常之少．关于软件错误本质的信息可以为改进将来的设计、编码和测试过程提供有</p>
<p>价值的反馈信息。</p>
<p>任何程序员和编程机构都可以从详细分析发现的错误，或至少一部分错误的过</p>
<p>程中获得提高。错误分析是一项困难且费时的工作，相比“有百分之多少的错误是第 7 章 调试(DEBUGGING) </p>
<p>未经同意，严禁以任何形式拷贝 </p>
<p>130</p>
<p>逻辑设计错误” 、“有百分之多少的错误出现在 IF 语句中”这些肤浅的分类，它</p>
<p>蕴涵的内容要多得多。详细的错误分析会包括如下内容：</p>
<p>z <strong>错误出现在什么地方？</strong>这个问题是最难回答的问题之一，它需要通过对程</p>
<p>序文档和项目历史进行回溯研究，但同时它也是最有价值的问题。它要求</p>
<p>我们指出该错误的源头和发生时间。举例来说，错误的源头可能是规格说</p>
<p>明中的一个模棱两可的语句，对先前错误的一次修改，或对最终用户需求</p>
<p>的一个错误理解，</p>
<p>z <strong>谁制造了这个错误？</strong>如果发现有 60 ％的设计错误都是由 10 名软件分析</p>
<p>师中的某个人犯下的，或某程序员犯的错是其他程序员的 3 倍，难道这不</p>
<p>是相当有用么？（不是为了处罚某人，而是为了进行培训。） </p>
<p>z <strong>哪些做得不正确？</strong>仅仅判断错误的发生时间和出现人员还不够，其中丢失</p>
<p>的环节是准确地判断出错误发生的原因。错误是由于某人写得不清楚？是</p>
<p>由干某人缺乏对该编程语言的培训？是打字错误？假设做得不对？还是因</p>
<p>为没有考虑有效输入？</p>
<p>z <strong>如何避免该错误的出现？</strong>在下一个项目中可以进行哪些调整以避免该问题</p>
<p>的出现？此向题的答案就是我们所寻找的最为宝贵的反馈信息或知识。</p>
<p>z <strong>为什么错误没有早些发现？</strong>如果错误是在测试引入段发现的，我们就应该</p>
<p>研究为什么在更早些的测试阶段、代码审查和设计评审中没有发现该错误。</p>
<p>z <strong>该如何更早地发现错误？</strong>这个问题的答案是另一个宝贵的反馈信息。该如</p>
<p>何改进评审和测试过程以便在将来的项目中更早地发现同类型的错误？假</p>
<p>设分析的问题不是由最终用户发现的（也就是说，是由测试用例发现的），</p>
<p>我们就应意识发生了一些有价值的事情：我们编写了一个成功的测试用例。</p>
<p>这个测试用例为什么会成功？我们是否能从中学习些什么，无论是针对该</p>
<p>程序还是将来的程序，设计出更多的成功用例？</p>
<p>再一次申明，分析的过程是很艰难的，但是找到的答案为改进后续的编程实践</p>
<p>提供极其宝贵的价值。值得警惕的是，绝大多数的程序员和编程机构都尚未使用这</p>
<p>种方法。</p>
<!-- /content -->
      <footer>
        <p>Posted by <a href="/author/hgx.html">hgx</a> on <time datetime="2023-05-25T20:38:43.258681+02:00">周四 25 五月 2023</time> in <a href="/category/ruan-jian-ce-shi.html">软件测试</a>. <span class="m-label m-success">updated <time datetime="2023-05-25T20:38:43.258681+02:00">周四 25 五月 2023</time></span></p>
      </footer>
    </article>
    <nav class="m-navpanel m-col-m-2">
      <h3>Categories</h3>
      <ol class="m-block-bar-m">
        <li><a href="/category/ruan-jian-ce-shi.html">软件测试</a></li>
        <li><a href="/category/jing-yan-lei-ji.html">经验累积</a></li>
        <li><a href="/category/blog.html">blog</a></li>
      </ol>
    </nav>
  </div>
</div>
</main>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <dl>
        <dt>The_toast. Powered by <a href="https://getpelican.com">Pelican</a></dt>
        <dd>and <a href="https://mcss.mosra.cz">m.css</a>.</dd>
        </dl>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>