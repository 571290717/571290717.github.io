# 开发指南

# Node.js API

## [#](https://vuepress.vuejs.org/zh/api/node.html#使用)使用

```js
const { createApp, dev, build, eject } = require('vuepress')
```

## [#](https://vuepress.vuejs.org/zh/api/node.html#方法)方法

### [#](https://vuepress.vuejs.org/zh/api/node.html#createapp-options-promise-app)createApp([options]): Promise<App>

创建一个 VuePress 应用实例。

#### [#](https://vuepress.vuejs.org/zh/api/node.html#app-prototype-process-promise-void-never)App.prototype.process: () => Promise<void> | never

用于准备当前站点上下文的异步方法。其中包含加载页面和插件、应用插件等。

#### [#](https://vuepress.vuejs.org/zh/api/node.html#app-prototype-dev-promise-app-never)App.prototype.dev: () => Promise<App> | never

使用当前应用程序上下文启动一个 devProcess.

#### [#](https://vuepress.vuejs.org/zh/api/node.html#app-prototype-build-promise-app-never)App.prototype.build: () => Promise<App> | never

使用当前应用程序上下文启动一个 buildProcess.

### [#](https://vuepress.vuejs.org/zh/api/node.html#dev-options-promise-app)dev([options]): Promise<App>

启动一个 Dev Server，实际上它是由 `createapp` 实现的：

```js
async function dev (options) {
  const app = createApp(options)
  await app.process()
  return app.dev()
}
```

### [#](https://vuepress.vuejs.org/zh/api/node.html#build-options-promise-app)build([options]): Promise<App>

将源文件构建为静态站点, 实际上它是由 `createapp` 实现的：

```js
async function build (options) {
  const app = createApp(options)
  await app.process()
  return app.build()
}
```

### [#](https://vuepress.vuejs.org/zh/api/node.html#eject-targetdir-promise-void)eject(targetDir): Promise<void>

将默认主题复制到 `{targetDir}/.vuepress/theme`中进行自定义。

## [#](https://vuepress.vuejs.org/zh/api/node.html#options)Options

### [#](https://vuepress.vuejs.org/zh/api/node.html#sourcedir)sourceDir

- 类型: `string`
- 默认值: `true`

指定 VuePress 站点的源目录。

### [#](https://vuepress.vuejs.org/zh/api/node.html#theme)theme

- 类型: `string`
- 默认值: `false`

参见 [theme](https://vuepress.vuejs.org/zh/config/#theme)。

### [#](https://vuepress.vuejs.org/zh/api/node.html#plugins)plugins

- 类型: `array`
- 默认值: `false`

参见 [plugins](https://vuepress.vuejs.org/zh/config/#plugins)。

### [#](https://vuepress.vuejs.org/zh/api/node.html#temp)temp

- 类型: `string`
- 默认值: `false`

参见 [temp](https://vuepress.vuejs.org/zh/config/#temp)。

### [#](https://vuepress.vuejs.org/zh/api/node.html#dest)dest

- 类型: `string`
- 默认值: `false`

参见 [dest](https://vuepress.vuejs.org/zh/config/#dest)。

### [#](https://vuepress.vuejs.org/zh/api/node.html#siteconfig)siteConfig

- 类型: `object`
- 默认值: `{}`

当你想编写测试且不想依赖于实际的配置文件时，它将非常有用。想要查看所有的配置选项，请移步 [siteConfig](https://vuepress.vuejs.org/zh/config/)。

# VuePress 1.x 的设计理念

VuePress 1.x 的设计理念主要体现在以下几个方面：

1. 插件化
2. 约定大于配置
3. 合理的优先级管理

## [#](https://vuepress.vuejs.org/zh/miscellaneous/design-concepts.html#插件化)插件化

VuePress 1.0 进行了大范围的重写，其中最重要的就是引入 [Plugin API](https://vuepress.vuejs.org/zh/plugin/)，那么插件带来的好处究竟是什么呢？

### [#](https://vuepress.vuejs.org/zh/miscellaneous/design-concepts.html#解耦)解耦

有了插件，我们可以将很多核心功能用插件来实现，你可以在[这里 (opens new window)](https://github.com/vuejs/vuepress/tree/master/packages/%40vuepress/core/lib/node/internal-plugins)看到很多内置的插件，这些插件涵盖了很多 VuePress 的核心功能，在以前，它们糅合在代码库的各个地方，但现在，它们一目了然。

### [#](https://vuepress.vuejs.org/zh/miscellaneous/design-concepts.html#配置的管理)配置的管理

在过去，当我们遇到一些不太常见的需求时，我们会有一些疑虑：如果我们打算不支持，VuePress 的使用场景也就受到了限制；但如果想要支持它，我们就必须将其写到核心代码库中，并为其单独开设配置的 API。对于维护者来说，除了不利于长久的维护，这有时也会让我们心力交瘁。我们必须想到一些更好的解决办法，没错，这个办法就是插件。

### [#](https://vuepress.vuejs.org/zh/miscellaneous/design-concepts.html#vuepress-config-js-也是插件)`.vuepress/config.js` 也是插件

没错，你的配置文件也是一个插件，因此，你可以直接使用插件 API，而不必为此新建一个插件，然后在配置中导入它。

提示

`.vuepress/config.js` 所支持的 API，实际上是在插件选项的基础上又新增了一些特定的选项。

### [#](https://vuepress.vuejs.org/zh/miscellaneous/design-concepts.html#theme-index-js-也是插件)`theme/index.js` 也是插件

主题的根配置文件也是插件。

提示

和 `.vuepress/config.js` 一样，`theme/index.js` 所支持的选项，也是在插件选项的基础上，又新增了一些特定的选项。用一张图来表达它们的关系就是：

.vuepress/ 

config.js

Plugin API

theme/ index.js

### [#](https://vuepress.vuejs.org/zh/miscellaneous/design-concepts.html#在插件中使用插件)在插件中使用插件

在 VuePress 中，你拥有在插件中使用插件的能力：

```js
// vuepress-plugin-xxx
module.exports = {
  plugins: [
    'a', 'b', 'c'
  ]
}
```

## [#](https://vuepress.vuejs.org/zh/miscellaneous/design-concepts.html#约定大于配置)约定大于配置

VuePress 1.0 开始引入一些约定，以减少用户过多的配置压力。对于这一点，最直观的体现是对[文档目录结构](https://vuepress.vuejs.org/zh/guide/directory-structure.html)和[主题目录结构](https://vuepress.vuejs.org/zh/theme/writing-a-theme.html#目录结构)的约定。

未来我们可能还会结合社区的反馈来引入更多的约定，让我们拭目以待。

## [#](https://vuepress.vuejs.org/zh/miscellaneous/design-concepts.html#合理的优先级管理)合理的优先级管理

资深的 VuePress 用户可能已经发现，主题开发者和普通的文档用户都具有定义全局的 `palette`、`style`、`templates` 和 `plugins` 的能力，那么他们是如何协同工作的呢？

### [#](https://vuepress.vuejs.org/zh/miscellaneous/design-concepts.html#加载优先级)加载优先级

`templates/*` 遵循一定的加载优先级，以 `templates/ssr.html` 为例：

用户的 ssr.html是否存在?使用用户的 ssr.html主题的 ssr.html是否存在?使用主题的 ssr.html使用默认的 ssr.htmlyesnoyesno

注意

当你想要去自定义 `templates/ssr.html` 或 `templates/dev.html` 时，最好基于 [默认的模板文件 (opens new window)](https://github.com/vuejs/vuepress/blob/master/packages/%40vuepress/core/lib/app/index.dev.html)来修改，否则可能会导致构建出错。

### [#](https://vuepress.vuejs.org/zh/miscellaneous/design-concepts.html#overriding)Overriding

对于 `palette.styl`、`index.styl` 和 `plugins`, 遵循 `overriding` 的原则：

#### [#](https://vuepress.vuejs.org/zh/miscellaneous/design-concepts.html#palette-styl)`palette.styl`

用户的 `styles/palette.styl` 具有比主题的 `styles/palette.styl` 更高的优先级，因此主题可以先预定义一套调色板，而用户又可以根据自身需要修改它。例如：

```stylus
// theme/styles/palette.styl
$accentColor = #0f0
// .vuepress/styles/palette.styl
$accentColor = #f00
```

`$accentColor` 最终的值是 `#f00`。

#### [#](https://vuepress.vuejs.org/zh/miscellaneous/design-concepts.html#index-styl)`index.styl`

用户和主题的 `styles/index.styl` 都会被生成到最终的 CSS 文件中，但是默认情况下，用户的样式会生成在主题的样式后面，因此对于同样的选择器，用户的样式将具有更高的优先级，如：

```stylus
// theme/styles/index.styl
.content
  font-size 14px
// .vuepress/styles/index.styl
.content
  font-size 15px
```

最终生成的 CSS 文件如下：

```css
/* theme/styles/index.styl */
.content {
  font-size: 14px;
}

/* theme/styles/index.styl */
.content {
  font-size: 15px;
}
```

#### [#](https://vuepress.vuejs.org/zh/miscellaneous/design-concepts.html#plugins)`plugins`

由于同名插件默认情况下只能应用一次，因此用户可以修改主题中预置的插件选项的默认值，如：

```js
// theme/index.js
module.exports = {
  plugins: [
    'vuepress-plugin-xxx',
    { name: 'foo' }
  ]
}
// .vuepress/config.js
module.exports = {
  plugins: [
    'vuepress-plugin-xxx',
    { name: 'bar' }
  ]
}
```

name 的最终值将是 `bar`.

## [#](https://vuepress.vuejs.org/zh/miscellaneous/design-concepts.html#其他)其他

本着解耦的目标，引入 monorepo 后，我们也得以将 VuePress 分离成以下两个库：

- [@vuepress/core (opens new window)](https://github.com/vuejs/vuepress/tree/master/packages/@vuepress/core)：包含 dev、build 的核心实现和 Plugin API；
- [@vuepress/theme-default (opens new window)](https://github.com/vuejs/vuepress/tree/master/packages/@vuepress/theme-default)：你现在所看到的默认主题。

当然，对于大多数用户来说，你并不需要关心上述三个库，[vuepress (opens new window)](https://www.npmjs.com/search?q=vuepress)这个包已经将上述三个包组装在一起，因此你完全可以像 `0.x` 那样使用 VuePress。

# FAQ

## [#](https://vuepress.vuejs.org/zh/faq/#为什么不能把-palette-styl-和-index-styl-合并到一个-api)为什么不能把 `palette.styl` 和 `index.styl` 合并到一个 API?

`palete.styl` 负责全局颜色设置。在编译期间，主题颜色常量应该首先由预处理器解析，然后应用于全局上下文。

但对于 `index.styl`，它的工作是重写应用的默认样式。根据 CSS 的优先级原则，后一种样式具有更高的优先级，因此应该在 CSS 文件的末尾生成。

描述 stylus 编译器编译顺序的简单图表如下：

palette.styl默认 app 样式index.styl



## [#](https://vuepress.vuejs.org/zh/faq/#clientdynamicmodules-和-enhanceappfiles-的区别是什么)`clientDynamicModules` 和 `enhanceAppFiles` 的区别是什么?

让我们先来回顾一下，`clientDynamicModules` 和 `enhanceAppFiles` 都可以在编译期间通过动态 JavaScript 代码生成模块。

不同之处在于，当应用在客户端初始化时，`enhanceAppFiles` 生成的文件会自动加载和使用；而 `clientDynamicModules` 生成的文件则需要用户自己引入 `@dynamic/xxx`。

```js
module.exports = (options, ctx) => ({
  // 被入口文件自动引入
  enhanceAppFiles: {
    name: 'constans-a',
    content: `...`
  },

  // 需要引入 '@dynamic/constans-b' 后使用
  clientDynamicModules() {
    return {
      name: 'constans-b',
      content: `...`
    }
  }
})
```

## [#](https://vuepress.vuejs.org/zh/faq/#什么时候需要使用-enhanceappfiles)什么时候需要使用 `enhanceAppFiles`?

1. 当你需要在客户端自动执行一些代码时；
2. 当你不需要复用这个模块时。

**比如：**

- [@vuepress/plugin-register-components (opens new window)](https://github.com/vuejs/vuepress/tree/master/packages/@vuepress/plugin-register-components/index.js#L24)：在客户端自动注册组件
- [@vuepress/plugin-google-analytics (opens new window)](https://github.com/vuejs/vuepress/blob/master/packages/@vuepress/plugin-google-analytics/enhanceAppFile.js)：自动配置 Google Analytics

## [#](https://vuepress.vuejs.org/zh/faq/#什么时候需要使用-clientdynamicmodules)什么时候需要使用 `clientDynamicModules`?

1. 当你需要生成一个在特定时间被调用的动态模块时；
2. 当你需要复用这个模块。

**比如：**

- [@vuepress/plugin-blog (opens new window)](https://github.com/vuepressjs/vuepress-plugin-blog/blob/master/src/node/index.ts#L208)：使用编译期元数据生成一些博客相关的动态模块并通过 `enhanceAppFiles` 将他们在客户端初始化

# 术语

你可能会在文档中碰到一些陌生的概念，本节列出了文档中常见的术语，方便查阅、学习、插件/主题开发之用。

## [#](https://vuepress.vuejs.org/zh/miscellaneous/glossary.html#layout)layout

- Access: `$page.frontmatter.layout`

当前页面所使用的布局组件名。

## [#](https://vuepress.vuejs.org/zh/miscellaneous/glossary.html#frontmatter)frontmatter

- Access: `$page.frontmatter`

当前页面的 `markdown` 文件中包裹在 `---` 中的配置，一般用于做一些页面级别的配置，参考 [Front Matter](https://vuepress.vuejs.org/zh/guide/frontmatter.html) 一节了解更多。

## [#](https://vuepress.vuejs.org/zh/miscellaneous/glossary.html#permalink)permalink

- Access: `$page.frontmatter.permalink`

永久链接，参考 [Permalinks](https://vuepress.vuejs.org/zh/guide/permalinks.html) 一节了解更多。

## [#](https://vuepress.vuejs.org/zh/miscellaneous/glossary.html#regularpath)regularPath

- Access: `$page.regularPath`

当前页面基于目录结构生成的 URL。

## [#](https://vuepress.vuejs.org/zh/miscellaneous/glossary.html#path)path

- Access: `$page.path`

当前页面的实际 URL。在构建期生成路由时，一个页面的 URL 将优先使用 `permalink`，若不存在则降级到 `regularPath`。

## [#](https://vuepress.vuejs.org/zh/miscellaneous/glossary.html#headers)headers

- Access: `$page.headers`

即 `markdown` 中那些以一个或多个 `#` 定义的标题。

## [#](https://vuepress.vuejs.org/zh/miscellaneous/glossary.html#siteconfig)siteConfig

- Access: `$site | Context.siteConfig`

即 `.vuepress/config.js`，译为 `站点配置`。

## [#](https://vuepress.vuejs.org/zh/miscellaneous/glossary.html#themeconfig)themeConfig

- Access: `$themeConfig | Context.themeConfig`

即 `.vuepress/config.js` 中 `themeConfig` 的值，是用户对当前所使用的主题的配置。

## [#](https://vuepress.vuejs.org/zh/miscellaneous/glossary.html#themepath)themePath

- Access: `Context.themeAPI.theme.path`

当前使用的主题的所在的绝对路径。

## [#](https://vuepress.vuejs.org/zh/miscellaneous/glossary.html#themeentry)themeEntry

- Access: `Context.themeAPI.theme.entry`

主题的配置文件 `themePath/index.js`。

## [#](https://vuepress.vuejs.org/zh/miscellaneous/glossary.html#parentthemepath)parentThemePath

- Access: `Context.themeAPI.parentTheme.path`

如果当前使用的主题是一个派生主题，那么 `parentThemePath` 就是指父主题的所在绝对路径。

## [#](https://vuepress.vuejs.org/zh/miscellaneous/glossary.html#parentthemeentry)parentThemeEntry

- Access: `Context.themeAPI.parentTheme.entry`

如果当前使用的主题是一个派生主题，那么 `parentThemePath` 就是指父主题的主题的配置文件 `parentThemePath/index.js`。

















